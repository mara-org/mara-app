# Mara CD ‚Äì Deploy APK
# Builds and deploys the Flutter app to production
# TODO: Add staging environment deployment - see enterprise audit
# TODO: Add preview deployments for PRs - see enterprise audit
# TODO: Add rollback mechanism - see enterprise audit
# TODO: Add build signing for production - see enterprise audit

name: Mara CD ‚Äì Deploy APK

on:
  push:
    branches:
      - main  # Trigger on main branch pushes
    tags:
      - 'v*.*.*'  # Trigger on semantic version tags (e.g., v1.0.0, v2.1.3)
  workflow_dispatch:  # Allow manual trigger from the Actions tab

jobs:
  deploy:
    name: Build & Deploy
    runs-on: ubuntu-latest

    env:
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_DEPLOYS }}
      ENVIRONMENT: production

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.27.0"

      - name: Flutter pub get
        run: flutter pub get

      - name: Extract app version
        run: |
          if grep -q '^version:' pubspec.yaml; then
            VERSION_LINE=$(grep '^version:' pubspec.yaml | head -n 1)
            VERSION_VALUE=$(echo "$VERSION_LINE" | awk '{print $2}')
          else
            VERSION_VALUE="unknown"
          fi
          echo "APP_VERSION=$VERSION_VALUE" >> $GITHUB_ENV

      - name: Mark start time
        run: echo "DEPLOY_START_TIME=$(date +%s)" >> $GITHUB_ENV

      - name: Build Flutter APK
        id: build_apk
        run: |
          flutter build apk --release
          if [ -f "build/app/outputs/flutter-apk/app-release.apk" ]; then
            echo "‚úÖ APK built successfully"
            echo "apk_path=build/app/outputs/flutter-apk/app-release.apk" >> $GITHUB_OUTPUT
          else
            echo "‚ùå APK build failed or file not found"
            exit 1
          fi

      - name: Build Flutter App Bundle (AAB)
        id: build_aab
        continue-on-error: true
        run: |
          flutter build appbundle --release
          if [ -f "build/app/outputs/bundle/release/app-release.aab" ]; then
            echo "‚úÖ AAB built successfully"
            echo "aab_path=build/app/outputs/bundle/release/app-release.aab" >> $GITHUB_OUTPUT
            echo "aab_built=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è AAB build failed or file not found (non-critical)"
            echo "aab_built=false" >> $GITHUB_OUTPUT
          fi

      - name: Prepare artifact names
        id: artifact_names
        run: |
          SHORT_SHA="${GITHUB_SHA::7}"
          VERSION="${{ env.APP_VERSION }}"
          TAG_NAME="${{ github.ref_name }}"
          
          # Use tag name if available, otherwise use version + commit
          if [[ "$TAG_NAME" == v* ]]; then
            ARTIFACT_SUFFIX="$TAG_NAME"
          else
            ARTIFACT_SUFFIX="v${VERSION}-${SHORT_SHA}"
          fi
          
          echo "apk_name=mara-android-apk-${ARTIFACT_SUFFIX}" >> $GITHUB_OUTPUT
          echo "aab_name=mara-android-aab-${ARTIFACT_SUFFIX}" >> $GITHUB_OUTPUT
          echo "artifact_suffix=${ARTIFACT_SUFFIX}" >> $GITHUB_OUTPUT

      - name: Check for signing secrets
        id: signing_check
        run: |
          if [ -n "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" ] && \
             [ -n "${{ secrets.ANDROID_KEY_ALIAS }}" ] && \
             [ -n "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" ] && \
             [ -n "${{ secrets.ANDROID_KEY_PASSWORD }}" ]; then
            echo "‚úÖ Signing secrets found"
            echo "signing_available=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è Signing secrets not configured"
            echo "signing_available=false" >> $GITHUB_OUTPUT
          fi

      - name: Sign APK (if secrets available)
        if: steps.signing_check.outputs.signing_available == 'true'
        run: |
          echo "üîê Signing APK with provided keystore..."
          
          # Decode keystore
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > /tmp/keystore.jks
          
          # Sign APK using apksigner (preferred) or jarsigner
          if command -v apksigner &> /dev/null; then
            apksigner sign \
              --ks /tmp/keystore.jks \
              --ks-key-alias "${{ secrets.ANDROID_KEY_ALIAS }}" \
              --ks-pass pass:"${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" \
              --key-pass pass:"${{ secrets.ANDROID_KEY_PASSWORD }}" \
              --out build/app/outputs/flutter-apk/app-release-signed.apk \
              build/app/outputs/flutter-apk/app-release.apk
            
            # Replace unsigned with signed
            mv build/app/outputs/flutter-apk/app-release-signed.apk \
               build/app/outputs/flutter-apk/app-release.apk
            echo "‚úÖ APK signed with apksigner"
          else
            # Fallback to jarsigner
            jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 \
              -keystore /tmp/keystore.jks \
              -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" \
              -keypass "${{ secrets.ANDROID_KEY_PASSWORD }}" \
              build/app/outputs/flutter-apk/app-release.apk \
              "${{ secrets.ANDROID_KEY_ALIAS }}"
            echo "‚úÖ APK signed with jarsigner"
          fi
          
          # Clean up keystore
          rm -f /tmp/keystore.jks
          echo "signing_completed=true" >> $GITHUB_OUTPUT

      - name: Sign AAB (if secrets available)
        if: steps.signing_check.outputs.signing_available == 'true' && steps.build_aab.outputs.aab_built == 'true'
        run: |
          echo "üîê Signing AAB with provided keystore..."
          
          # Decode keystore
          echo "${{ secrets.ANDROID_KEYSTORE_BASE64 }}" | base64 -d > /tmp/keystore.jks
          
          # Sign AAB using jarsigner
          jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 \
            -keystore /tmp/keystore.jks \
            -storepass "${{ secrets.ANDROID_KEYSTORE_PASSWORD }}" \
            -keypass "${{ secrets.ANDROID_KEY_PASSWORD }}" \
            build/app/outputs/bundle/release/app-release.aab \
            "${{ secrets.ANDROID_KEY_ALIAS }}"
          
          # Clean up keystore
          rm -f /tmp/keystore.jks
          echo "‚úÖ AAB signed"

      - name: Upload APK artifact
        if: steps.build_apk.outputs.apk_path != ''
        uses: actions/upload-artifact@v5
        with:
          name: ${{ steps.artifact_names.outputs.apk_name }}
          path: build/app/outputs/flutter-apk/app-release.apk
          retention-days: 90
          if-no-files-found: error

      - name: Upload AAB artifact
        if: steps.build_aab.outputs.aab_built == 'true'
        uses: actions/upload-artifact@v5
        with:
          name: ${{ steps.artifact_names.outputs.aab_name }}
          path: build/app/outputs/bundle/release/app-release.aab
          retention-days: 90
          if-no-files-found: warn

      - name: Deploy summary
        if: steps.signing_check.outputs.signing_available == 'false'
        run: |
          echo "‚ÑπÔ∏è Signing skipped: keystore secrets not configured yet."
          echo "   To enable signing, configure these secrets in GitHub:"
          echo "   - ANDROID_KEYSTORE_BASE64"
          echo "   - ANDROID_KEY_ALIAS"
          echo "   - ANDROID_KEYSTORE_PASSWORD"
          echo "   - ANDROID_KEY_PASSWORD"
          echo ""
          echo "Build artifacts are available as GitHub Actions artifacts."
          echo "No backend/server deployment configured (frontend-only repo)."

      - name: Compute deploy duration
        run: |
          END_TIME=$(date +%s)
          START_TIME=${DEPLOY_START_TIME:-$END_TIME}
          DURATION=$((END_TIME - START_TIME))
          echo "DEPLOY_DURATION=$DURATION" >> $GITHUB_ENV

      - name: Notify Discord (final status)
        if: always()
        run: |
          STATUS="${{ job.status }}"
          COMMIT_URL="https://github.com/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}"
          RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          ICON="‚úÖ"
          TITLE="Mara Frontend Build & Deploy Succeeded"
          if [ "$STATUS" != "success" ]; then
            ICON="‚ùå"
            TITLE="Mara Frontend Build or Deploy FAILED"
          fi

          # Build message
          MESSAGE="${ICON} **${TITLE}**
          Status: \`${STATUS}\`
          Environment: \`${ENVIRONMENT}\`
          Version: \`${APP_VERSION:-unknown}\`
          Repo: \`${GITHUB_REPOSITORY}\`
          Branch: \`${GITHUB_REF_NAME}\`
          Actor: \`${GITHUB_ACTOR}\`
          Commit: [\`${GITHUB_SHA::7}\`](${COMMIT_URL})
          Total time: \`${DEPLOY_DURATION:-unknown}s\`
          Workflow: ${RUN_URL}"

          # Properly escape JSON using Python
          echo "$MESSAGE" > /tmp/discord_msg.txt
          PAYLOAD=$(python3 -c "import json; f=open('/tmp/discord_msg.txt'); msg=f.read(); f.close(); print(json.dumps({'content': msg}))")

          # Send to Discord with error handling
          echo "Sending notification to Discord..."
          echo "Webhook URL: ${DISCORD_WEBHOOK:0:50}..." # Show first 50 chars for debugging
          
          HTTP_CODE=$(curl -s -o /tmp/discord_response.txt -w "%{http_code}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -X POST "$DISCORD_WEBHOOK")
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 204 ]; then
            echo "‚úÖ Discord notification sent successfully (HTTP $HTTP_CODE)"
          else
            echo "‚ùå Failed to send Discord notification (HTTP $HTTP_CODE)"
            echo "Response:"
            cat /tmp/discord_response.txt
            echo ""
            echo "Payload preview (first 200 chars):"
            echo "$PAYLOAD" | head -c 200
            exit 1
          fi

