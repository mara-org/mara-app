# Frontend CI workflow for Mara Flutter app
# Runs code formatting checks, static analysis, tests, and coverage collection
# TODO: Add multi-platform testing (iOS, Android, Web) - see enterprise audit
# TODO: Add integration tests - see enterprise audit
# TODO: Enforce 80%+ coverage threshold (currently warning at 60%)

name: Flutter CI

on:
  push:
    branches: ['**']  # Trigger on push to any branch
  pull_request:
    branches:
      - main  # Trigger on PR to main

jobs:
  ci:
    name: Flutter CI
    runs-on: ubuntu-latest

    env:
      DISCORD_WEBHOOK: ${{ secrets.DISCORD_WEBHOOK_EVENTS }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: "3.27.0"

      - name: Cache Flutter pub dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.pub-cache
            ${{ github.workspace }}/.dart_tool
          key: ${{ runner.os }}-flutter-pub-${{ hashFiles('**/pubspec.lock') }}
          restore-keys: |
            ${{ runner.os }}-flutter-pub-

      - name: Cache Gradle dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
            android/.gradle
          key: ${{ runner.os }}-gradle-${{ hashFiles('**/gradle-wrapper.properties', '**/build.gradle.kts', '**/build.gradle') }}
          restore-keys: |
            ${{ runner.os }}-gradle-

      - name: Flutter pub get
        run: flutter pub get

      - name: Check code formatting
        id: format_check
        run: |
          echo "ðŸ“ Checking code formatting..."
          dart format --output=none --set-exit-if-changed . || {
            echo "âŒ Code formatting check failed."
            echo "Please run 'dart format .' to fix formatting issues."
            echo "format_passed=false" >> $GITHUB_OUTPUT
            exit 1
          }
          echo "âœ… Code formatting check passed."
          echo "format_passed=true" >> $GITHUB_OUTPUT

      - name: Flutter analyze
        id: analyze
        run: |
          # Run analyze and capture output
          set +e  # Don't exit on error
          flutter analyze > analyze_output.txt 2>&1
          ANALYZE_EXIT_CODE=$?
          cat analyze_output.txt
          
          # Count errors and warnings (not info)
          # Strip whitespace and newlines to ensure clean integer values
          ERRORS=$(grep -c "error â€¢" analyze_output.txt 2>/dev/null | tr -d '[:space:]' || echo "0")
          WARNINGS=$(grep -c "warning â€¢" analyze_output.txt 2>/dev/null | tr -d '[:space:]' || echo "0")
          
          # Ensure we have valid integers (default to 0 if empty)
          ERRORS=${ERRORS:-0}
          WARNINGS=${WARNINGS:-0}
          
          # Set GitHub output variables
          echo "analyze_errors=$ERRORS" >> $GITHUB_OUTPUT
          echo "analyze_warnings=$WARNINGS" >> $GITHUB_OUTPUT
          
          # Only fail if there are errors or warnings
          if [ "$ERRORS" -gt 0 ] || [ "$WARNINGS" -gt 0 ]; then
            echo "Found $ERRORS errors and $WARNINGS warnings. Failing build."
            exit 1
          else
            echo "Only info-level linting suggestions found. Build continues."
            exit 0
          fi

      - name: Run tests with coverage
        id: test_coverage
        run: |
          echo "ðŸ§ª Running tests with coverage..."
          flutter test --coverage || {
            echo "âŒ Tests failed."
            echo "coverage_generated=false" >> $GITHUB_OUTPUT
            exit 1
          }
          
          # Check if coverage file exists
          if [ -f "coverage/lcov.info" ]; then
            echo "âœ… Coverage file generated."
            echo "coverage_generated=true" >> $GITHUB_OUTPUT
            
            # Try to parse coverage percentage (approximate)
            # This is a simple approach - for more accurate parsing, use lcov tools
            TOTAL_LINES=$(grep -c "^DA:" coverage/lcov.info 2>/dev/null || echo "0")
            HIT_LINES=$(grep "^DA:" coverage/lcov.info | grep -v ",0$" | wc -l || echo "0")
            
            if [ "$TOTAL_LINES" -gt 0 ]; then
              # Calculate percentage (approximate)
              COVERAGE_PERCENT=$((HIT_LINES * 100 / TOTAL_LINES))
              echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
              echo "ðŸ“Š Coverage: ~${COVERAGE_PERCENT}%"
              
              # Check coverage threshold (warning at 60%, TODO: enforce 80%+)
              if [ "$COVERAGE_PERCENT" -lt 60 ]; then
                echo "âš ï¸ WARNING: Coverage is below 60% (currently ~${COVERAGE_PERCENT}%)"
                echo "TODO: Enforce 80%+ coverage threshold in future"
              else
                echo "âœ… Coverage is above 60% threshold"
              fi
            else
              echo "âš ï¸ Could not parse coverage percentage"
              echo "coverage_percent=unknown" >> $GITHUB_OUTPUT
            fi
          else
            echo "âš ï¸ Coverage file not found"
            echo "coverage_generated=false" >> $GITHUB_OUTPUT
            echo "coverage_percent=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Upload coverage artifact
        if: steps.test_coverage.outputs.coverage_generated == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: coverage-report
          path: coverage/lcov.info
          retention-days: 7

      - name: Notify Discord (final status)
        if: always()
        continue-on-error: true
        run: |
          set +e  # Don't exit on error
          
          STATUS="${{ job.status }}"
          FORMAT_PASSED="${{ steps.format_check.outputs.format_passed }}"
          COVERAGE_GENERATED="${{ steps.test_coverage.outputs.coverage_generated }}"
          COVERAGE_PERCENT="${{ steps.test_coverage.outputs.coverage_percent }}"
          ANALYZE_ERRORS="${{ steps.analyze.outputs.analyze_errors }}"
          ANALYZE_WARNINGS="${{ steps.analyze.outputs.analyze_warnings }}"
          
          COMMIT_URL="https://github.com/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}"
          RUN_URL="https://github.com/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"

          # Build status message
          if [ "$STATUS" = "success" ]; then
            ICON="âœ…"
            TITLE="Mara Frontend CI passed"
          else
            ICON="âŒ"
            TITLE="Mara Frontend CI failed"
          fi
          
          # Format status
          if [ "$FORMAT_PASSED" = "true" ]; then
            FORMAT_STATUS="âœ… Passed"
          else
            FORMAT_STATUS="âŒ Failed"
          fi
          
          # Coverage status
          if [ "$COVERAGE_GENERATED" = "true" ]; then
            if [ "$COVERAGE_PERCENT" != "unknown" ]; then
              COVERAGE_STATUS="âœ… Generated (~${COVERAGE_PERCENT}%)"
            else
              COVERAGE_STATUS="âœ… Generated (percentage unknown)"
            fi
          else
            COVERAGE_STATUS="âŒ Not generated"
          fi
          
          MESSAGE="${ICON} **${TITLE}**

          Branch: \`${GITHUB_REF_NAME}\`
          Actor: \`${GITHUB_ACTOR}\`
          Commit: [\`${GITHUB_SHA::7}\`](${COMMIT_URL})
          
          **Checks:**
          Format: ${FORMAT_STATUS}
          Analyze: ${ANALYZE_ERRORS} errors, ${ANALYZE_WARNINGS} warnings
          Coverage: ${COVERAGE_STATUS}
          
          Run: ${RUN_URL}"

          # Check if webhook is set
          if [ -z "$DISCORD_WEBHOOK" ]; then
            echo "âš ï¸ DISCORD_WEBHOOK_EVENTS secret is not set. Skipping notification."
            exit 0
          fi

          # Properly escape JSON using Python (with error handling)
          echo "$MESSAGE" > /tmp/discord_msg.txt 2>/dev/null
          if [ $? -ne 0 ]; then
            echo "âš ï¸ Failed to create message file. Skipping notification."
            exit 0
          fi
          
          PAYLOAD=$(python3 -c "import json; f=open('/tmp/discord_msg.txt'); msg=f.read(); f.close(); print(json.dumps({'content': msg}))" 2>/dev/null)
          if [ $? -ne 0 ] || [ -z "$PAYLOAD" ]; then
            echo "âš ï¸ Failed to create JSON payload. Skipping notification."
            exit 0
          fi

          # Send to Discord with error handling
          echo "Sending notification to Discord..."
          echo "Webhook URL: ${DISCORD_WEBHOOK:0:50}..." # Show first 50 chars for debugging
          
          HTTP_CODE=$(curl -s -o /tmp/discord_response.txt -w "%{http_code}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD" \
            -X POST "$DISCORD_WEBHOOK" 2>/dev/null)
          CURL_EXIT=$?
          
          if [ $CURL_EXIT -ne 0 ]; then
            echo "âš ï¸ curl command failed with exit code $CURL_EXIT"
            echo "Note: Discord notification failure does not affect CI status."
            exit 0
          fi
          
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "204" ]; then
            echo "âœ… Discord notification sent successfully (HTTP $HTTP_CODE)"
          else
            echo "âš ï¸ Failed to send Discord notification (HTTP $HTTP_CODE)"
            echo "Response:"
            cat /tmp/discord_response.txt 2>/dev/null || echo "No response body"
            echo ""
            echo "Payload preview (first 200 chars):"
            echo "$PAYLOAD" | head -c 200 2>/dev/null || echo "Could not preview payload"
            echo ""
            echo "Note: Discord notification failure does not affect CI status."
          fi
          
          # Always exit successfully to not fail the CI job
          exit 0
