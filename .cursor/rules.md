# Mara – Cursor Global Engineering Rules

> These rules apply to **all future work** that Cursor performs inside this repository.  
> Project family: **Mara** (all apps, services, and tooling owned by Mara).

Cursor **must always follow these rules automatically**, without waiting for the user to remind it, for **every new feature, method, class, file, or architectural change**.

---

## 0. Scope & Identity

- This repository is part of the **Mara** ecosystem.
- All code, docs, and tests generated by Cursor are:
  - Written **for Mara**.
  - Owned by **Mara** (the company / product), not by individual developers.
- Backend lives in a **separate repository** but follows the **same philosophy** and rules (architecture, docs, testing, automation).

---

## 1. General Behavior

For **every edit** Cursor makes (create / modify / refactor):

1. Treat the repo as **production-grade, enterprise-level** (Google/Stripe/GitHub standards).
2. Prefer:
   - Explicitness over magic.
   - Readability over cleverness.
   - Predictability over “short hacks”.
3. Never introduce “temporary quick fixes” or “TODO later” unless:
   - They are logged as issues, OR
   - They are clearly documented with rationale.

Cursor must **never**:
- Leave new code **untested**.
- Leave new behavior **undocumented**.
- Silently break existing contracts/APIs.

---

## 2. Documentation Sync – Always Up to Date

Whenever Cursor **adds or changes behavior**, it must **immediately update all relevant docs**.

### 2.1. Which docs to touch?

Depending on the change, update one or more of:

- Root docs:
  - `README.md`
  - `CONTRIBUTING.md`
  - `ARCHITECTURE.md`
  - `SECURITY.md`
  - `API_REFERENCE.md` (if exists)
  - `CHANGELOG.md` (if manually maintained)
- Feature / domain docs:
  - `docs/*.md`
  - `docs/architecture/**/*.md`
  - `docs/features/**/*.md`
  - Any design / decision files impacted.

### 2.2. Documentation Rules

For each **new feature / endpoint / widget / module / use case**:

1. Add a short **“What”** description (purpose, high-level behavior).
2. Add **“How it works”** (flow, inputs/outputs, dependencies).
3. List **constraints & assumptions** (rate limits, auth requirements, environment flags, etc.).
4. If applicable, add:
   - Example usage (code snippet or HTTP example).
   - Edge cases or failure modes.
   - Links to related tests.

Cursor must **not**:
- Add code that changes behavior without adjusting docs.
- Leave outdated docs; always refactor the docs to match the current implementation.

---

## 3. Testing – Every Change Must Be Covered

For **every new method, class, endpoint, widget, or feature**, Cursor must:

1. **Generate tests automatically**.
2. Ensure **all tests pass** before considering the work “done”.
3. Aim for:
   - **100% coverage** of the new code it writes or modifies.
   - No flaky / time-dependent / random tests.

### 3.1. Test Types (Frontend – Flutter)

If this is a **Flutter / frontend** repo, Cursor must:

- For core logic (pure Dart code):
  - Create **unit tests** under `test/unit/` or `test/` with clear naming.
- For UI components:
  - Create **widget tests** under `test/widget/` to verify layout, state, and behavior.
- For full flows:
  - Add or update **integration tests** under `integration_test/`.

### 3.2. Test Types (Backend / API Repos)

If this is a **backend** repo, Cursor must:

- For business logic:
  - Add **unit tests**.
- For HTTP APIs:
  - Add **integration tests** (happy path + error paths).
- For database-related operations:
  - Use test DB / mocks / transactions rollback.
- For critical flows:
  - Add **end-to-end tests** if feasible.

### 3.3. Test Quality Rules

All generated tests must:

- Be **deterministic** (no random sleeps, time-based failures, or network dependence unless mocked).
- Cover:
  - Success path
  - Common error paths
  - Edge cases (null/empty/invalid inputs)
- Use descriptive names:
  - `should_do_X_when_Y`
  - `returns_error_when_condition_Z`

Cursor should:
- Prefer **mocking external services** (network, file system, DB) where possible.
- Avoid tests that depend on external internet or real 3rd-party systems.

---

## 4. Architecture & Clean Code Rules

Cursor must respect and enforce the architecture chosen for Mara.

### 4.1. Separation of Concerns

- Keep **UI / Presentation** separate from:
  - Business logic (domain layer)
  - Data access (repositories / services)
- Avoid:
  - Direct HTTP calls inside UI widgets.
  - Business rules inside controllers/pages.

### 4.2. Repositories & Use Cases

When reading/writing data (API, DB, cache), Cursor should:

1. Use or create **Repository interfaces** (e.g., `AuthRepository`, `UserRepository`).
2. Use **use cases / services** for non-trivial business logic.
3. Keep:
   - Repositories → I/O duties (remote / local).
   - Use cases → orchestration + rules.

### 4.3. Architecture Documentation

Whenever the architecture is extended/changed:

- Update `ARCHITECTURE.md` and relevant files under `docs/architecture/`.
- If a significant decision is made (e.g., new pattern, new dependency, or breaking change), add or update an ADR under:
  - `docs/architecture/decisions/*`

---

## 5. ADRs (Architecture Decision Records)

For major decisions (new tech, patterns, or large refactors), Cursor must:

1. Create or update an ADR in:  
   - `docs/architecture/decisions/NNNN-some-decision.md`
2. Include:
   - Context
   - Decision
   - Alternatives considered
   - Consequences (pros & cons)

Cursor should:
- Reuse existing ADR templates if present.
- Keep ADRs in **English**, clear, and structured.

---

## 6. Security & Privacy Rules

Cursor must **always** treat this project as if it handles **sensitive user data** (even if dummy):

- Never:
  - Log secrets, tokens, passwords, or health-related private data.
  - Hardcode API keys, secrets, or environment variables.
- Always:
  - Use environment configuration / secrets management.
  - Sanitize user input where relevant.
  - Respect existing `SECURITY.md` practices.

If Cursor introduces new:
- Auth mechanisms
- Sensitive flows
- Security-sensitive logic

It must:
- Update `SECURITY.md` with:
  - New risks
  - Mitigations
  - Required configs

---

## 7. Observability & Logging

When adding non-trivial logic (especially network or stateful behavior), Cursor must:

1. Use the existing **logging / observability** abstraction if available (e.g. `Logger`, `ObservabilityService`, etc.).
2. Add **structured logs** for:
   - Failures
   - Timeouts
   - Unexpected branches
3. Respect:
   - No logging of PHI / sensitive personal data.
   - Use log levels correctly (info / warning / error).

If the repository has analytics / metrics:

- For new user flows, Cursor should:
  - Add tracking for key events (started, succeeded, failed).
  - Add performance timing where appropriate.

---

## 8. CI/CD & Automation Expectations

When Cursor changes **project structure, tooling, or dependencies**, it must:

1. Ensure relevant CI workflows (e.g. `.github/workflows/*.yml`) are still valid and updated.
2. If a new command is needed (for tests, lint, codegen), update:
   - `README.md` (Usage section)
   - `CONTRIBUTING.md` (Development / testing section)
   - Any scripts / Makefiles / package scripts.

If new tests are added:
- Make sure they are runnable in CI (no local-only dependencies).

---

## 9. Style, Naming & Conventions

Cursor must:

- Follow the existing style & conventions:
  - Naming patterns for files, classes, methods.
  - Folder structure & module boundaries.
- When unsure:
  - Inspect existing similar code and follow the same pattern.
- Commit / PR expectations (even if simulated):
  - Use **Conventional Commits** style in examples:
    - `feat:`
    - `fix:`
    - `refactor:`
    - `test:`
    - `docs:`
    - `chore:`

---

## 10. When the User Asks for “Quick Feature / Small Change”

Even if the user says things like:

- “بس اضف شيء بسيط”
- “سوي ميثود سريعة”
- “حط هالتعديل وبس”

Cursor must **still**:

1. Generate or update tests relevant to this change.
2. Update the documentation as needed.
3. Keep the system consistent with the rules above.

No change is “too small” to skip tests or docs.

---

## 11. When to Ask for Clarification

Cursor should **only** ask the user for clarification if:

- The requested change **conflicts** with these rules, or
- The change would **break architecture or security** in a significant way.

Otherwise, Cursor must:
- Make a **reasonable, conservative assumption**.
- Document that assumption in code comments and/or docs.

---

## 12. Summary – One Sentence Contract

> For every future change I (Cursor) make in this repository for **Mara**, I will **always**:
> - Keep documentation in sync,
> - Generate and maintain high-quality tests,
> - Respect architecture, security, and observability,
> - And treat this codebase as an enterprise-grade, production system.

These rules are **permanent** and apply automatically to **all future commands** inside this repo.